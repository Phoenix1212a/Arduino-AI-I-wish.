const unsigned char imgone [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xdb, 0x6d, 0xb6, 0xdb, 0x77, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x7f, 0xff, 0xff, 0xff, 0xde, 0xfb, 0x7b, 0xef, 0xbe, 0xff, 0xff, 0xff, 0xff, 0x7b, 0xde, 0xf7, 
	0xf7, 0xbe, 0xfb, 0xef, 0xff, 0xff, 0xef, 0xbe, 0xfb, 0xf7, 0xfb, 0xbd, 0xef, 0xff, 0xff, 0xff, 
	0xde, 0xf7, 0xdf, 0x7d, 0xfd, 0xef, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xef, 0x7b, 0xdf, 
	0x7f, 0xff, 0x7d, 0xf7, 0xb7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xfd, 
	0xfb, 0xdb, 0xf7, 0xff, 0xff, 0xfd, 0xbe, 0xff, 0xff, 0xdf, 0xfe, 0xf7, 0xbf, 0xff, 0xff, 0xff, 
	0xef, 0x7f, 0xdf, 0xbf, 0x7f, 0xbf, 0xfb, 0xf7, 0xbe, 0xfe, 0xff, 0xff, 0xff, 0xbd, 0xef, 0x7f, 
	0xbf, 0xfd, 0xfe, 0xfb, 0xfd, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xf7, 
	0xfd, 0xef, 0xbf, 0xff, 0xef, 0xf7, 0xef, 0xff, 0xff, 0xff, 0xff, 0xde, 0xf7, 0xf7, 0xbd, 0xff, 
	0x77, 0xbe, 0xfb, 0xdf, 0x7f, 0xff, 0xff, 0xde, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xff, 0xfb, 0xff, 0xfb, 0xff, 0x7f, 0x7f, 0xff, 0xff, 0xdf, 0xdf, 0xff, 0xfe, 0xff, 0xff, 0xfd, 
	0xde, 0xff, 0xdd, 0xbf, 0xfb, 0xff, 0xfe, 0xff, 0xef, 0x7f, 0xfe, 0xfb, 0xdf, 0xfd, 0xef, 0x7f, 
	0xf7, 0xdf, 0x7f, 0xff, 0x7f, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0xf7, 
	0xbf, 0x7b, 0xf7, 0xef, 0xf7, 0xff, 0xf7, 0xfd, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xfd, 0xff, 
	0xff, 0xff, 0xfe, 0xfd, 0xff, 0xdf, 0xff, 0xf7, 0xfd, 0xfb, 0xfb, 0xdf, 0x7b, 0xff, 0x7f, 0xde, 
	0xf6, 0xf7, 0xbf, 0xdf, 0xdf, 0x7f, 0xdf, 0xff, 0xf7, 0xff, 0xff, 0xfd, 0xff, 0xf7, 0xf7, 0xff, 
	0xdf, 0xfe, 0xf7, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0x7b, 
	0xff, 0xdf, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xbf, 0xff, 0xdf, 0xef, 0x7f, 0xef, 0xff, 0x7f, 0xff, 
	0xbd, 0xfd, 0xee, 0xf7, 0xfb, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xf7, 0xff, 0xfd, 0xf6, 0xef, 
	0xff, 0xbf, 0xff, 0xff, 0xe9, 0xfb, 0xff, 0xff, 0x61, 0xfd, 0x9f, 0xff, 0xfd, 0xef, 0xff, 0xfe, 
	0xf7, 0xfb, 0xbd, 0xef, 0xec, 0x7f, 0xfd, 0xfd, 0xcd, 0xfc, 0xef, 0xff, 0x7f, 0xff, 0xdf, 0xdf, 
	0xff, 0x7f, 0xff, 0xfe, 0xdf, 0x7f, 0xff, 0xff, 0xbc, 0xfb, 0xef, 0xbf, 0xff, 0xbf, 0x7f, 0x7d, 
	0xdf, 0xf7, 0xf7, 0xbf, 0xde, 0x7f, 0xff, 0xff, 0x9f, 0xfb, 0xdf, 0xfb, 0xef, 0xfb, 0xfb, 0xff, 
	0xfd, 0xff, 0x7f, 0xff, 0xee, 0xff, 0xef, 0xf7, 0x7c, 0xf6, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xf7, 
	0xbf, 0xdf, 0xfe, 0xfb, 0xbe, 0x7f, 0xbf, 0xff, 0x3d, 0xf5, 0xee, 0xff, 0xbd, 0xef, 0xdf, 0x7f, 
	0xfb, 0xfd, 0xef, 0xef, 0xbd, 0x7d, 0xff, 0xfe, 0xfb, 0xf7, 0xef, 0xef, 0xff, 0xfe, 0xfd, 0xee, 
	0xff, 0xbf, 0xff, 0xff, 0xdd, 0x7f, 0xff, 0xbe, 0x7a, 0xeb, 0xdf, 0xfe, 0xff, 0xbf, 0xf7, 0xff, 
	0xef, 0xfb, 0xbf, 0xbf, 0x78, 0xff, 0xff, 0xfd, 0x7d, 0xef, 0xbf, 0xff, 0xef, 0xfb, 0xdf, 0xdd, 
	0xfe, 0xff, 0xfb, 0xff, 0xba, 0xff, 0xfd, 0xfd, 0x75, 0xe7, 0xbf, 0x7d, 0xfe, 0xff, 0xff, 0x7f, 
	0xff, 0xef, 0xff, 0xff, 0xb3, 0xff, 0xe7, 0xfe, 0xf7, 0xf7, 0x9f, 0xe6, 0xfe, 0xef, 0x7d, 0xfb, 
	0xbf, 0xff, 0xff, 0xff, 0x6f, 0x7b, 0xbb, 0xfe, 0x7b, 0xde, 0xff, 0xc9, 0x33, 0x7f, 0xf7, 0xef, 
	0xfb, 0xfd, 0xdf, 0xf7, 0x6d, 0xdf, 0xbc, 0xf5, 0x6f, 0xc7, 0x3d, 0x9d, 0x4d, 0xfd, 0xff, 0xbf, 
	0xff, 0xbf, 0xfe, 0xff, 0xbf, 0xbf, 0x6f, 0x7d, 0xe7, 0xf7, 0x7f, 0x7f, 0x4d, 0xef, 0xbe, 0xfd, 
	0xff, 0xff, 0xff, 0xfe, 0xff, 0xbf, 0x7f, 0xfc, 0xdf, 0xcc, 0xff, 0x3f, 0x9f, 0xfe, 0xf7, 0xf7, 
	0xdf, 0xff, 0x7f, 0xff, 0x5f, 0xff, 0x9e, 0xfc, 0x7f, 0xed, 0xf6, 0xff, 0x9f, 0xbf, 0xfd, 0xde, 
	0xfe, 0xf7, 0xfb, 0xfd, 0xfe, 0x7e, 0xff, 0xfd, 0x5f, 0xe7, 0xfe, 0x77, 0x8f, 0xf7, 0xdf, 0xff, 
	0xff, 0xff, 0xff, 0xd8, 0xbf, 0xdf, 0x7b, 0x7d, 0x7f, 0x63, 0xbd, 0xfd, 0xbd, 0xde, 0xf7, 0x7b, 
	0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0x5f, 0xfc, 0xff, 0xdb, 0xf9, 0x3f, 0x9f, 0x7f, 0xbf, 0xdf, 
	0xfb, 0xff, 0xdf, 0x07, 0x7e, 0xbf, 0xb7, 0xf6, 0x7d, 0xc7, 0xf9, 0xfe, 0x5f, 0xfb, 0xfb, 0xf7, 
	0xdf, 0xfe, 0xfe, 0x1f, 0xff, 0xff, 0xbf, 0xe6, 0x3f, 0x33, 0xe1, 0x36, 0x7b, 0xef, 0x7e, 0xfe, 
	0xff, 0xef, 0xfe, 0x7e, 0xf7, 0x6d, 0xc9, 0x3b, 0x88, 0xb0, 0x07, 0x99, 0xbf, 0xbf, 0xdf, 0xbf, 
	0xff, 0xff, 0xff, 0xfe, 0xff, 0xf7, 0x76, 0xcf, 0xa6, 0xfc, 0x97, 0xca, 0xf7, 0xfb, 0xf7, 0xed, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xfe, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfd, 0xff, 
	0xff, 0x7f, 0xf7, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfd, 0xef, 0xb7, 0xbf, 0x77, 
	0xfd, 0xff, 0x7f, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0x7f, 0xef, 0xbd, 0xff, 0xef, 0xde, 
	0xff, 0xff, 0xff, 0xdf, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xfd, 0xed, 0xff, 0xff, 0xdd, 0xfb, 0xfb, 
	0xff, 0xff, 0xff, 0x7f, 0xff, 0xfb, 0xf7, 0xfb, 0xbd, 0xff, 0xff, 0xde, 0xf7, 0xf7, 0x7e, 0xef, 
	0xf7, 0xfb, 0xff, 0xff, 0xef, 0xff, 0xff, 0x7f, 0xff, 0xdf, 0xdf, 0xfb, 0xde, 0xff, 0xdf, 0xbe, 
	0xff, 0xff, 0xff, 0xff, 0x7f, 0xdf, 0xff, 0xff, 0xff, 0xfd, 0xfd, 0xbf, 0xfb, 0xbb, 0xf7, 0xfb, 
	0xff, 0xff, 0xdf, 0xff, 0xff, 0x7f, 0xdf, 0xef, 0xef, 0x7f, 0xff, 0xf7, 0x7f, 0xee, 0xfd, 0xdf, 
	0xff, 0xdf, 0xfe, 0xfb, 0xfd, 0xff, 0xff, 0xff, 0x7f, 0xf7, 0xb7, 0xff, 0xde, 0xff, 0xbf, 0x76, 
	0xff, 0x7f, 0xff, 0xff, 0xf7, 0xfe, 0xfd, 0xff, 0xfe, 0xff, 0xfe, 0xdd, 0xf7, 0xbb, 0xef, 0xff, 
	0xfd, 0xfe, 0xff, 0xff, 0xdf, 0xfb, 0xff, 0xff, 0xfb, 0xee, 0xfb, 0xf7, 0xfd, 0xee, 0xfb, 0xbb, 
	0xf7, 0xff, 0xfb, 0xef, 0xff, 0xff, 0xff, 0xbd, 0xff, 0xff, 0xdf, 0xfe, 0xdf, 0xff, 0xbe, 0xee, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xef, 0xff, 0xdf, 0xdf, 0x7f, 0x6f, 0xf6, 0xdd, 0xef, 0xff, 
	0xff, 0xfb, 0xff, 0xfe, 0xff, 0x7f, 0xff, 0xff, 0xff, 0x7d, 0xfb, 0xfd, 0xbf, 0xf7, 0x7b, 0x77, 
	0xff, 0xff, 0xdf, 0xbf, 0xfb, 0xff, 0xff, 0xf7, 0xfd, 0xff, 0xef, 0xbf, 0xfb, 0x7f, 0xdf, 0xdd, 
	0xff, 0xdf, 0xff, 0xff, 0xef, 0xfe, 0xfd, 0xff, 0x77, 0xf7, 0xbe, 0xf6, 0xdf, 0xdb, 0xf6, 0xff, 
	0xff, 0xff, 0xff, 0xfb, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xdf, 0xf6, 0xfe, 0xff, 0xb6, 
	0xfb, 0xff, 0xfd, 0xff, 0xff, 0xef, 0xff, 0xdf, 0xff, 0xbf, 0xf7, 0x7b, 0x7f, 0xb7, 0xbb, 0xff, 
	0xff, 0xfe, 0xff, 0xff, 0xbf, 0xbf, 0xef, 0xff, 0xdf, 0xfb, 0xdd, 0xff, 0xdb, 0xfd, 0xee, 0xdb, 
	0xff, 0xfb, 0xff, 0xef, 0xfe, 0xff, 0xff, 0xfd, 0xfd, 0xef, 0x7f, 0xdd, 0xfe, 0xdf, 0x7f, 0xfe, 
	0xff, 0xef, 0xf7, 0xff, 0xfb, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xfb, 0x77, 0x6f, 0xf7, 0xdb, 0x6f
};


const unsigned char imgtwo [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xb6, 0xdb, 0x6d, 0xb6, 0xef, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xbd, 0xf6, 0xef, 0x7d, 0xf7, 0xbf, 0xff, 0xff, 0xfd, 0xef, 0x7b, 0xdf, 
	0x7b, 0xbd, 0xde, 0xef, 0xff, 0xff, 0xff, 0xf7, 0xdf, 0xff, 0xde, 0xef, 0x77, 0xff, 0xff, 0xfd, 
	0xef, 0xf7, 0xfb, 0xfd, 0xfb, 0xdf, 0xfd, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xde, 0xf7, 0xbf, 
	0xfe, 0xff, 0x7f, 0xbf, 0xdf, 0xff, 0xbf, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xbf, 0xbd, 0xef, 0xfb, 0xff, 0xbd, 0xff, 0xff, 0xff, 0xfe, 0xf7, 0xbd, 0xff, 0xbf, 0xef, 0xf7, 
	0xed, 0xef, 0xfb, 0x7f, 0x7e, 0xff, 0xf7, 0xde, 0xf7, 0xff, 0xff, 0xff, 0xde, 0xfb, 0xfe, 0xff, 
	0x7f, 0xff, 0x7f, 0xef, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 
	0xff, 0xbd, 0xef, 0xfe, 0xff, 0xf7, 0xbf, 0x7f, 0xff, 0xff, 0xbd, 0xef, 0xff, 0xff, 0xff, 0xde, 
	0xed, 0xf7, 0xfd, 0xbf, 0xef, 0xdf, 0xff, 0xfb, 0xde, 0xff, 0xff, 0xfe, 0xf7, 0xef, 0xf7, 0xff, 
	0xff, 0xdf, 0xbf, 0xf7, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0x7e, 0xff, 0x7b, 
	0xbb, 0xfe, 0xfb, 0xdf, 0x7d, 0xff, 0xef, 0xff, 0xff, 0xff, 0xef, 0xbf, 0xff, 0xff, 0xff, 0xff, 
	0xef, 0x7b, 0xef, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xfb, 0xdf, 0xfe, 0xfb, 0xdf, 0xff, 0xdd, 0xef, 
	0x7f, 0xef, 0xfe, 0xfb, 0xdf, 0xff, 0xff, 0xf7, 0xbf, 0xff, 0x7f, 0xff, 0xfd, 0xf7, 0xff, 0xff, 
	0xfd, 0xff, 0xbf, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0x7b, 0xdd, 
	0xef, 0xde, 0xfb, 0x7f, 0x7b, 0xdf, 0xff, 0xff, 0xff, 0x7f, 0xfb, 0xfe, 0xff, 0xff, 0xff, 0xff, 
	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xdf, 0xff, 0xfb, 0xff, 0xdf, 0xef, 0xfe, 0xff, 0x7b, 
	0xbf, 0xfb, 0xdf, 0xf7, 0xef, 0xfe, 0xff, 0x7f, 0xdf, 0xff, 0xdf, 0xff, 0xfe, 0xfb, 0xef, 0xff, 
	0xf7, 0xdf, 0xfb, 0xdf, 0x7f, 0xfb, 0xff, 0xfe, 0xfd, 0xff, 0x7f, 0x7b, 0xff, 0xef, 0xfe, 0xef, 
	0x7f, 0x7e, 0xfe, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xe3, 0xfe, 0xdf, 0xff, 0xbf, 0xff, 0xdf, 0xff, 
	0xfb, 0xfb, 0xef, 0xfd, 0xee, 0x7f, 0xfb, 0xff, 0x9a, 0xf6, 0xdf, 0xff, 0xfb, 0xff, 0x7d, 0xfd, 
	0xef, 0xef, 0xff, 0xf7, 0xcf, 0x7f, 0xff, 0xfb, 0xbc, 0xf9, 0xe7, 0xff, 0xff, 0xbd, 0xff, 0xb7, 
	0xff, 0xff, 0x7d, 0xbf, 0xfe, 0x7f, 0xdf, 0xff, 0xbd, 0xff, 0xff, 0xbb, 0xef, 0xff, 0xfb, 0xff, 
	0xbe, 0xff, 0xf7, 0xff, 0x9e, 0xff, 0x7f, 0xff, 0x3d, 0xf3, 0xde, 0xff, 0xbf, 0x7b, 0xef, 0xfe, 
	0xff, 0xed, 0xff, 0xff, 0xee, 0x7d, 0xff, 0xde, 0x7c, 0xf7, 0xcf, 0xff, 0xff, 0xff, 0xbf, 0xbb, 
	0xf7, 0xbf, 0xdf, 0xfb, 0xbe, 0x7f, 0xff, 0x7e, 0xfb, 0xf7, 0xff, 0xfe, 0xfd, 0xef, 0xfe, 0xff, 
	0xff, 0xff, 0xfe, 0xef, 0xbc, 0xff, 0xff, 0xfe, 0xbb, 0xeb, 0xb7, 0xef, 0xff, 0xfe, 0xfb, 0xef, 
	0xbe, 0xfd, 0xbf, 0xff, 0xd9, 0xff, 0xfb, 0xfe, 0x7d, 0xef, 0xbf, 0xbf, 0xef, 0xbf, 0xef, 0xfd, 
	0xfb, 0xf7, 0xfd, 0xff, 0x79, 0xfb, 0xef, 0xfd, 0x75, 0xe7, 0x9f, 0xff, 0xbe, 0xfb, 0xff, 0xbf, 
	0xff, 0xdf, 0xff, 0xff, 0x73, 0xef, 0xfd, 0xf6, 0xf7, 0xf7, 0xfe, 0xf1, 0xfe, 0xff, 0xbd, 0xfb, 
	0xef, 0xff, 0xf7, 0xff, 0x9e, 0xff, 0x96, 0xfe, 0xfb, 0xcf, 0x3f, 0xcc, 0x73, 0x77, 0xf7, 0xdf, 
	0xff, 0xfe, 0xff, 0xdf, 0xee, 0xbf, 0xf7, 0xbc, 0x6f, 0xee, 0xff, 0x26, 0x8d, 0xfe, 0xff, 0xfd, 
	0xfe, 0xfb, 0xff, 0xfd, 0x7b, 0xff, 0x5e, 0xfd, 0xe7, 0xe6, 0xf7, 0xbf, 0xad, 0xef, 0xee, 0xef, 
	0xbf, 0xef, 0xfe, 0xff, 0x5f, 0x7f, 0x7e, 0xfc, 0xdf, 0xdd, 0x7f, 0x7f, 0x9f, 0xff, 0x7f, 0xbe, 
	0xff, 0xff, 0xdf, 0xff, 0xff, 0xbb, 0xbf, 0xfc, 0xdf, 0xcd, 0xfe, 0x7e, 0xcf, 0xbd, 0xf7, 0xfb, 
	0xfb, 0xff, 0xff, 0xfc, 0xbf, 0xef, 0xbd, 0xfd, 0x3f, 0xe3, 0xfe, 0xdf, 0x9e, 0xff, 0xde, 0xff, 
	0xff, 0xff, 0xff, 0xe1, 0xff, 0x7e, 0x7f, 0x7d, 0x7e, 0xeb, 0xd9, 0x7d, 0x9f, 0xf7, 0xfb, 0xde, 
	0xff, 0xbe, 0xfd, 0xe1, 0xdf, 0xbf, 0xdb, 0xfc, 0xff, 0xce, 0xfd, 0x7f, 0x9d, 0xfd, 0xbf, 0xf7, 
	0xff, 0xff, 0xf7, 0x8f, 0x7e, 0xff, 0x7f, 0xf6, 0x7f, 0xd3, 0xf1, 0xbb, 0x3f, 0xbf, 0xf7, 0x7d, 
	0xff, 0xff, 0xfe, 0x0f, 0x7f, 0xdf, 0x8f, 0xe6, 0x3e, 0x33, 0xe4, 0xbe, 0x7b, 0xee, 0xff, 0xdf, 
	0xf7, 0xfb, 0xfe, 0x7e, 0xff, 0x76, 0xf2, 0x5b, 0x89, 0xb0, 0x8b, 0x94, 0xdf, 0xfb, 0xdd, 0xfb, 
	0xff, 0xff, 0xdf, 0xfe, 0xfb, 0xff, 0xf6, 0xdf, 0xa4, 0xfc, 0x27, 0xd3, 0xfe, 0xdf, 0x77, 0xbe, 
	0xff, 0xbf, 0xff, 0xff, 0xff, 0xdb, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xbb, 0xff, 0xfe, 0xf7, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xef, 0xff, 0xbb, 0xbf, 0xff, 
	0xff, 0xff, 0x7f, 0xff, 0xdf, 0xff, 0xdf, 0xff, 0xff, 0xdf, 0xfd, 0xbf, 0x77, 0xee, 0xed, 0xdb, 
	0xf7, 0xff, 0xff, 0xf7, 0xff, 0x7f, 0x7f, 0xfb, 0xf7, 0xfd, 0xff, 0xff, 0xfe, 0xff, 0xff, 0x7e, 
	0xff, 0xfb, 0xfd, 0xff, 0xfd, 0xff, 0xff, 0xbf, 0xbf, 0x7f, 0xde, 0xfb, 0xdf, 0xbb, 0xb7, 0xef, 
	0xff, 0xbf, 0xff, 0xff, 0x7f, 0xfb, 0xfd, 0xff, 0xff, 0xf7, 0xf7, 0xef, 0x7b, 0xee, 0xfd, 0xfb, 
	0xff, 0xff, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0x7f, 0xbd, 0xef, 0x7f, 0xdf, 0x7e, 
	0xff, 0xff, 0xdf, 0xff, 0xf7, 0xff, 0xef, 0xfd, 0xfb, 0xff, 0xfe, 0xff, 0xfd, 0xf7, 0xf7, 0xdf, 
	0xfb, 0xff, 0x7f, 0xff, 0xff, 0xdf, 0xbf, 0xdf, 0xdf, 0xed, 0xef, 0xf7, 0xbf, 0xdd, 0xbd, 0xf7, 
	0xff, 0xf7, 0xfe, 0xfd, 0xff, 0x7e, 0xff, 0x7f, 0xff, 0xff, 0xfb, 0xde, 0xf7, 0x7f, 0xef, 0x7d, 
	0xff, 0xdf, 0xff, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0x7f, 0xdf, 0xf6, 0xfb, 0xdf, 
	0xff, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xfe, 0xfd, 0xf7, 0xdf, 0xf7, 0x7b, 0xbf, 0xbe, 0xf6, 
	0xff, 0xff, 0xf7, 0xff, 0xfd, 0xfb, 0xfb, 0xfb, 0xef, 0xfe, 0xfd, 0xfd, 0xfe, 0xed, 0xef, 0xbf, 
	0xf7, 0xff, 0xff, 0xdf, 0xff, 0xff, 0xef, 0xff, 0xff, 0xdf, 0xf7, 0xbf, 0xef, 0xff, 0x7b, 0xed, 
	0xff, 0xfd, 0xff, 0xff, 0x7f, 0xdf, 0xff, 0xdf, 0xff, 0xfd, 0xdf, 0xee, 0xfb, 0x77, 0xde, 0xff, 
	0xff, 0xbf, 0xdf, 0xff, 0xf7, 0xff, 0xff, 0xff, 0x7b, 0xf7, 0xfe, 0xfb, 0xbf, 0xdd, 0xf7, 0xb6, 
	0xff, 0xff, 0xfe, 0xfb, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xbf, 0xbb, 0xdf, 0xed, 0xff, 0x7d, 0xff, 
	0xff, 0xff, 0xff, 0xef, 0xff, 0x7f, 0xfd, 0xfb, 0xf7, 0xfe, 0xff, 0x7d, 0xff, 0x6f, 0xdf, 0x6d, 
	0xf7, 0xfb, 0xff, 0xff, 0xdf, 0xff, 0xef, 0xef, 0xdf, 0xf7, 0xef, 0xf7, 0x77, 0xfb, 0xf7, 0xff, 
	0xff, 0xdf, 0xf7, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0x7f, 0xbb, 0xbf, 0xdd, 0xbe, 0x7d, 0xb6, 
	0xff, 0xff, 0xdf, 0xff, 0x7d, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xfe, 0xed, 0xff, 0xef, 0xdf, 0xff
};




#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <WiFi.h>
#include <Keypad.h>

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
#define SCREEN_ADDRESS 0x3C

const int buttonUp = 32;
const int buttonDown = 33;
const int buttonSend = 34;

int16_t txt_x1, txt_y1;
uint16_t txt_w, txt_h;

bool computer;

const byte ROWS = 4;
const byte COLS = 4;
char keys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};

byte rowPins[ROWS] = {14,12,13,2};
byte colPins[COLS] = {4,23,17,16};
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);




// Scrolling
int scrollPos = 0;
int textHeight;
int textSpeed = 4;

char lastKey = NO_KEY;
int tapCount = 0;
int mode = 0; // 0=letters,1=numbers,2=symbols,3=exotic

String message = "";
String finalMessage = "";
String final = "";

bool uppercaseFlag = false;

bool preview = false;
bool messageSent = false;

bool computerResidue = false;

int KeypadScrollPos = 0;

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

const char* ssid = "Hotspot";
const char* password = "12121212";
const char* serverUrl = "https://eurythmical-eloisa-unrotating.ngrok-free.dev";

void resetMultiTap();
void handleKey(char key);
void outputCharacter(char key, int count);
char getPreviewChar(char key, int count);
void sendMessageToServer(String msg);

String cleanString(String s) {
    String out;
    out.reserve(s.length());
    for (size_t i = 0; i < s.length();) {
        if (s[i] == '\\' && i + 5 < s.length() && s[i+1] == 'u') {
            String hex = s.substring(i+2, i+6);
            char *endptr;
            long code = strtol(hex.c_str(), &endptr, 16);
            if (*endptr == 0) {
                switch (code) {
                    case 0x2019: out += '\''; break;
                    case 0x201C:
                    case 0x201D: out += '"'; break;
                    case 0x2026: out += "..."; break;
                    case 0x2013: out += '-'; break;
                    case 0x2014: out += "--"; break;
                    default:
                        if (code < 128) out += (char)code;
                        else out += '?';
                }
                i += 6;
                continue;
            }
        }
        out += s[i];
        i++;
    }
    return out;
}


const int MAX_PIXELS = 128 * 64 / 8;  // 1024 bytes for 128x64
unsigned char pixels[MAX_PIXELS];

void appendChunks(String &s) {
    int pixelCount = 0;

    for (int i = 0; i < s.length(); i += 8) {
        if (pixelCount >= MAX_PIXELS) break;

        uint8_t b = 0;
        for (int bit = 0; bit < 8; bit++) {
            int idx = i + bit;
            if (idx < s.length() && s[idx] == '1') {
                b |= (1 << bit);  // LSB first
            }
        }
        pixels[pixelCount++] = b;
    }
}



void setup() {
    pinMode(buttonUp, INPUT);
    pinMode(buttonDown, INPUT);
    pinMode(buttonSend, INPUT);
    Serial.begin(9600);

    if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
        Serial.println(F("SSD1306 allocation failed"));
        for (;;) {}
    }

    for (int i = 0; i < 3; i++) {
        display.clearDisplay();
        display.drawBitmap(0, 0, imgone, 128, 64, SSD1306_WHITE);
        display.display();
        delay(750);
        display.clearDisplay();
        display.drawBitmap(0, 0, imgtwo, 128, 64, SSD1306_WHITE);
        display.display();
        delay(750);
    }


    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    String ssidInput = "";
    String passInput = "";

    // --- Enter SSID ---
    finalMessage = "";
    message = "";
    preview = true;

    display.clearDisplay();
    display.setCursor(0, 0);
    display.println("Enter SSID:");
    display.display();

    while (true) {
        char key = keypad.getKey();
        if (key) handleKey(key);

        // Preview on display
        display.clearDisplay();
        display.setCursor(0, 0);
        display.println("Enter SSID:");
        display.print(finalMessage + message);
        display.setCursor(64, 32);
        display.print(getPreviewChar(key, tapCount));
        display.display();

        // If send button pressed, confirm SSID
        if (digitalRead(buttonSend) == HIGH && (finalMessage + message).length() > 0) {
            delay(200);
            ssidInput = finalMessage + message;
            finalMessage = "";
            message = "";
            resetMultiTap();
            break;
        }
        delay(20);
    }

    // --- Enter Password ---
    preview = true;
    display.clearDisplay();
    display.setCursor(0, 0);
    display.println("Enter Password:");
    display.display();

    while (true) {
        char key = keypad.getKey();
        if (key) handleKey(key);

        // Preview on display
        display.clearDisplay();
        display.setCursor(0, 0);
        display.println("Enter Password:");
        display.print(finalMessage + message);
        display.setCursor(64, 32);
        display.print(getPreviewChar(key, tapCount));
        display.display();

        // If send button pressed, confirm password
        if (digitalRead(buttonSend) == HIGH && (finalMessage + message).length() > 0) {
            delay(200);
            passInput = finalMessage + message;
            finalMessage = "";
            message = "";
            resetMultiTap();
            break;
        }
        delay(20);
    }

    // --- Connect WiFi ---
    display.clearDisplay();
    display.setCursor(0, 0);
    display.println("Connecting to WiFi...");
    display.display();
    WiFi.begin(ssidInput.c_str(), passInput.c_str());

    while (WiFi.status() != WL_CONNECTED) {
        if (digitalRead(buttonDown) == HIGH) { // Cancel connection
            display.clearDisplay();
            display.setCursor(0, 0);            
            display.println("WiFi connection canceled!");
            display.display();
            delay(2000);
            return;
        }
        delay(500);
        Serial.print(".");
    }

    display.clearDisplay();
    display.setCursor(0, 0);
    display.println("WiFi Connected!");
    display.display();
    delay(2000);
    display.clearDisplay();
    display.display();
}


void loop() {
    char key = keypad.getKey();
    if(key) handleKey(key);
    if (key != NO_KEY) preview = true;

    String displayText = preview ? (finalMessage) : finalMessage + final;
    display.getTextBounds(displayText.c_str(), 0, 0, &txt_x1, &txt_y1, &txt_w, &txt_h);
    textHeight = txt_h;

    if(digitalRead(buttonUp) == HIGH){
        if(preview){
            KeypadScrollPos -= textSpeed;
            if(KeypadScrollPos < 0) KeypadScrollPos = 0;
        } else {
            scrollPos -= textSpeed;
            if(scrollPos < 0) scrollPos = 0;
        }
        if(computerResidue) {
            computer = true;
        }
    }
    if(digitalRead(buttonDown) == HIGH){
        if(preview){
            KeypadScrollPos += textSpeed;
            if(KeypadScrollPos > max(0, textHeight - SCREEN_HEIGHT)) 
                KeypadScrollPos = max(0, textHeight - SCREEN_HEIGHT);
        } else {
            scrollPos += textSpeed;
            if(scrollPos > max(0, textHeight - SCREEN_HEIGHT))
                scrollPos = max(0, textHeight - SCREEN_HEIGHT);
        }
        if(computerResidue) {
            computerResidue = false;
        }
    }

    display.clearDisplay();


    unsigned long lastGetTime = 0;
    const unsigned long getInterval = 100; // 100 ms between GETs
    unsigned long startTime = millis();      // for 5-second timeout
    String lastPixelString = "";


    if (computer && computerResidue) {
        while (true) {
            // --- Handle keypad/button input continuously ---
            char key = keypad.getKey();
            if (key) {
                HTTPClient http;
                http.begin(String(serverUrl) + "/");
                http.addHeader("Content-Type", "application/json");
                String postData = "{\"input\": \"" + String(key) + "\"}";
                http.POST(postData);
                http.end();
            }

            if (digitalRead(buttonUp) == HIGH) { // exit computer mode
                computer = false;
                computerResidue = true;
                break;
            }

            // --- Only GET from server every 100 ms ---
            if (millis() - lastGetTime >= getInterval) {
                lastGetTime = millis();

                HTTPClient http2;
                http2.begin(String(serverUrl) + "/data");
                int httpCode = http2.GET();
                if (httpCode > 0) {
                    String pixelString = http2.getString();

                    // Only update pixels if different
                    if (pixelString != lastPixelString) {
                        appendChunks(pixelString);
                        lastPixelString = pixelString;
                    }
                }
                http2.end();
            }

            // --- Draw current pixels ---
            display.clearDisplay();
            display.drawBitmap(0, 0, pixels, 128, 64, SSD1306_WHITE);
            display.display();
        }
    }


    if(preview){

        if(digitalRead(buttonSend) == HIGH && message.length() > 0){
            finalMessage = message;
            Serial.print("Message sent: "); Serial.println(message);
            resetMultiTap();
            final = "";
            message = "";
            KeypadScrollPos = 0;
            preview = false;
            messageSent = false;
        }

        if(finalMessage.indexOf("/c" ) >= 0) {
            computerResidue = true;
            computer = true;
            HTTPClient http;
            http.begin(String(serverUrl) + "/");
            http.addHeader("Content-Type", "application/json");
            String postData = String("{\"input\": \"") + "/c" + "\"}";
            http.POST(postData);
            http.end();
        }

        display.setTextSize(1);
        display.setCursor(0, -KeypadScrollPos);
        display.print(finalMessage + message);

        if(lastKey != NO_KEY){
            display.setTextSize(2);
            display.setCursor((SCREEN_WIDTH/2)-6, (SCREEN_HEIGHT/2)-8);
            display.print(getPreviewChar(lastKey, tapCount));
            display.display();
        }

    } else {

        if(finalMessage.length() > 0 && !messageSent){
            sendMessageToServer(finalMessage);
            messageSent = true;
        }

        display.setTextSize(1);
        display.setCursor(0, -scrollPos);
        display.print(cleanString(final));
        display.display();
    }

    display.display();
    delay(20);
}

void resetMultiTap() {
    lastKey = NO_KEY;
    tapCount = 0;
}

void handleKey(char key) {
    if(key=='A'){
      static unsigned long lastATime = 0;
      unsigned long now = millis();
    
      if(now - lastATime < 500){
          Serial.println("Mode: Uppercase Letters");
          uppercaseFlag = true;
      } else {
          Serial.println("Mode: Lowercase Letters");
          uppercaseFlag = false;
      }
      
      mode = 0;
      lastATime = now;
      resetMultiTap();
      return;
    }

    if(key=='B'){ mode=1; resetMultiTap(); Serial.println("Mode: Numbers"); return; }
    if(key=='C'){ mode=2; resetMultiTap(); Serial.println("Mode: Symbols"); return; }
    if(key=='D'){ mode=3; resetMultiTap(); Serial.println("Mode: Exotic"); return; }

    if(key == '*') {
        if(lastKey != NO_KEY){
            Serial.println("Cancelled selection");
            resetMultiTap();
        }
        return;
    }

    if(key == '0'){
        if(mode == 1){
            lastKey = '0';
            tapCount = 0;
            Serial.println("Selecting 0...");
        } else {
            message += ' ';
            Serial.println("Added space");
            resetMultiTap();
        }
        return;
    }

    if(key == '#' && lastKey != NO_KEY){
        outputCharacter(lastKey, tapCount);
        Serial.print("Character accepted: "); Serial.println(message[message.length()-1]);
        resetMultiTap();
        return;
    }

    if(key >= '1' && key <= '9'){
        if(lastKey == key) tapCount++;
        else { lastKey = key; tapCount = 0; }
        char previewChar = getPreviewChar(lastKey, tapCount);
        Serial.print("Selecting: "); Serial.println(previewChar);
    }
}

void outputCharacter(char key, int count) {
    char c = getPreviewChar(key, count);
    message += c;
}

char getPreviewChar(char key, int count) {
    if(mode == 0){
        char c = ' ';
        if(key=='1'){ c = (count%3==0) ? '.' : (count%3==1) ? ',' : '\''; }
        if(key=='2'){ c = (count%3==0) ? 'a' : (count%3==1) ? 'b' : 'c'; }
        if(key=='3'){ c = (count%3==0) ? 'd' : (count%3==1) ? 'e' : 'f'; }
        if(key=='4'){ c = (count%3==0) ? 'g' : (count%3==1) ? 'h' : 'i'; }
        if(key=='5'){ c = (count%3==0) ? 'j' : (count%3==1) ? 'k' : 'l'; }
        if(key=='6'){ c = (count%3==0) ? 'm' : (count%3==1) ? 'n' : 'o'; }
        if(key=='7'){ c = (count%4==0) ? 'p' : (count%4==1) ? 'q' : (count%4==2) ? 'r' : 's'; }
        if(key=='8'){ c = (count%3==0) ? 't' : (count%3==1) ? 'u' : 'v'; }
        if(key=='9'){ c = (count%4==0) ? 'w' : (count%4==1) ? 'x' : (count%4==2) ? 'y' : 'z'; }
        
        if(uppercaseFlag){
            if(c >= 'a' && c <= 'z') c = toupper(c);
        }
        return c;
    }
    else if(mode == 1){
        if(key>='0' && key<='9') return key;
    }
    else if(mode == 2){
        if(key=='1'){ if(count%3==0) return '.'; else if(count%3==1) return ','; else return '\''; }
        if(key=='2'){ if(count%3==0) return '/'; else if(count%3==1) return '-'; else return '+'; }
        if(key=='3'){ if(count%3==0) return '!'; else if(count%3==1) return '@'; else return '#'; }
        if(key=='4'){ if(count%3==0) return '$'; else if(count%3==1) return '%'; else return '^'; }
        if(key=='5'){ if(count%3==0) return '&'; else if(count%3==1) return '*'; else return '('; }
        if(key=='6'){ if(count%3==0) return '_'; else if(count%3==1) return '='; else return '['; }
        if(key=='7'){ if(count%3==0) return '{'; else if(count%3==1) return '}'; else return '<'; }
        if(key=='8'){ if(count%3==0) return '>'; else if(count%3==1) return '~'; else return '`'; }
        if(key=='9'){ if(count%3==0) return '|'; else if(count%3==1) return ':'; else return ';'; }
    }
    else if(mode == 3){
        if(key=='1'){ if(count%2==0) return 'α'; else return 'Α'; }
        if(key=='2'){ if(count%2==0) return 'β'; else return 'Β'; }
        if(key=='3'){ if(count%2==0) return 'γ'; else return 'Γ'; }
        if(key=='4'){ if(count%2==0) return 'δ'; else return 'Δ'; }
        if(key=='5'){ if(count%2==0) return 'ε'; else return 'Ε'; }
        if(key=='6'){ if(count%2==0) return 'ζ'; else return 'Ζ'; }
        if(key=='7'){ if(count%2==0) return 'η'; else return 'Η'; }
        if(key=='8'){ if(count%2==0) return 'θ'; else return 'Θ'; }
        if(key=='9'){ if(count%2==0) return 'ι'; else return 'Ι'; }
        if(key=='0'){ if(count%2==0) return 'κ'; else return 'Κ'; }
        if(key=='*'){ if(count%2==0) return 'λ'; else return 'Λ'; }
        if(key=='#'){ if(count%2==0) return 'μ'; else return 'Μ'; }
    }
    return ' ';
}

void sendMessageToServer(String msg) {
    if (WiFi.status() != WL_CONNECTED) {
        final = msg + "\nWiFi not connected!\n\n" + final;
        return;
    }

    HTTPClient http;
    http.begin(String(serverUrl) + "/");
    http.addHeader("Content-Type", "application/json");
    String postData = "{\"input\": \"" + msg + "\"}";
    int postCode = http.POST(postData);
    Serial.print("POST response: ");
    Serial.println(postCode);
    http.end();

    http.begin(String(serverUrl) + "/data");
    int httpCode = http.GET();
    String serverReply = "";

    if (httpCode > 0) {
        serverReply = http.getString();
        serverReply.replace("\\n", "\n");
        serverReply = cleanString(serverReply);
    } else {
        serverReply = "GET error: " + String(httpCode);
    }
    http.end();

    final = msg + "\n" + serverReply + "\n\n" + final;

    finalMessage = "";
}